<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Class: EventMachine::Connection</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Class</strong></td>
          <td class="class-name-in-header">EventMachine::Connection</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>
                <a href="../../files/lib/eventmachine_rb.html">
                lib/eventmachine.rb
                </a>
        <br />
                <a href="../../files/lib/jeventmachine_rb.html">
                lib/jeventmachine.rb
                </a>
        <br />
                <a href="../../files/lib/pr_eventmachine_rb.html">
                lib/pr_eventmachine.rb
                </a>
        <br />
            </td>
        </tr>

        <tr class="top-aligned-row">
            <td><strong>Parent:</strong></td>
            <td>
                Object
            </td>
        </tr>
        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <p>
<a href="Connection.html">EventMachine::Connection</a> is a class that is
instantiated by <a href="../EventMachine.html">EventMachine</a>&#8216;s
processing loop whenever a new connection is created. (New connections can
be either initiated locally to a remote server or accepted locally from a
remote client.) When a <a href="Connection.html">Connection</a> object is
instantiated, it <em>mixes in</em> the functionality contained in the
user-defined module specified in calls to <a
href="../EventMachine.html#M000259">EventMachine#connect</a> or <a
href="../EventMachine.html#M000256">EventMachine#start_server</a>.
User-defined handler modules may redefine any or all of the standard
methods defined here, as well as add arbitrary additional code that will
also be mixed in.
</p>
<p>
<a href="../EventMachine.html">EventMachine</a> manages one object
inherited from <a href="Connection.html">EventMachine::Connection</a> (and
containing the mixed-in user code) for every network connection that is
active at any given time. The event loop will automatically call methods on
<a href="Connection.html">EventMachine::Connection</a> objects whenever
specific events occur on the corresponding connections, as described below.
</p>
<p>
This class is never instantiated by user code, and does not publish an
initialize method. The instance methods of <a
href="Connection.html">EventMachine::Connection</a> which may be called by
the event loop are: <a href="Connection.html#M000525">post_init</a>, <a
href="Connection.html#M000526">receive_data</a>, and <a
href="Connection.html#M000527">unbind</a>. All of the other instance
methods defined here are called only by user code.
</p>

    </div>


   </div>

    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">
      <a href="#M000546">associate_callback_target</a>&nbsp;&nbsp;
      <a href="#M000528">close_connection</a>&nbsp;&nbsp;
      <a href="#M000530">close_connection_after_writing</a>&nbsp;&nbsp;
      <a href="#M000540">comm_inactivity_timeout</a>&nbsp;&nbsp;
      <a href="#M000541">comm_inactivity_timeout=</a>&nbsp;&nbsp;
      <a href="#M000533">connection_completed</a>&nbsp;&nbsp;
      <a href="#M000529">detach</a>&nbsp;&nbsp;
      <a href="#M000532">error?</a>&nbsp;&nbsp;
      <a href="#M000547">get_outbound_data_size</a>&nbsp;&nbsp;
      <a href="#M000536">get_peername</a>&nbsp;&nbsp;
      <a href="#M000538">get_pid</a>&nbsp;&nbsp;
      <a href="#M000537">get_sockname</a>&nbsp;&nbsp;
      <a href="#M000539">get_status</a>&nbsp;&nbsp;
      <a href="#M000525">post_init</a>&nbsp;&nbsp;
      <a href="#M000526">receive_data</a>&nbsp;&nbsp;
      <a href="#M000543">reconnect</a>&nbsp;&nbsp;
      <a href="#M000531">send_data</a>&nbsp;&nbsp;
      <a href="#M000535">send_datagram</a>&nbsp;&nbsp;
      <a href="#M000544">send_file_data</a>&nbsp;&nbsp;
      <a href="#M000542">set_comm_inactivity_timeout</a>&nbsp;&nbsp;
      <a href="#M000534">start_tls</a>&nbsp;&nbsp;
      <a href="#M000545">stream_file_data</a>&nbsp;&nbsp;
      <a href="#M000527">unbind</a>&nbsp;&nbsp;
      </div>
    </div>

  </div>


    <!-- if includes -->

    <div id="section">





    <div id="attribute-list">
      <h3 class="section-bar">Attributes</h3>

      <div class="name-list">
        <table>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">signature</td>
          <td class="context-item-value">&nbsp;[RW]&nbsp;</td>
          <td class="context-item-desc">
EXPERIMENTAL. Added the <a href="Connection.html#M000543">reconnect</a>
methods, which may go away.

</td>
        </tr>
        </table>
      </div>
    </div>
      


    <!-- if method_list -->
    <div id="methods">
      <h3 class="section-bar">Public Instance methods</h3>

      <div id="method-M000546" class="method-detail">
        <a name="M000546"></a>

        <div class="method-heading">
          <a href="Connection.src/M000546.html" target="Code" class="method-signature"
            onclick="popupCode('Connection.src/M000546.html');return false;">
          <span class="method-name">associate_callback_target</span><span class="method-args">(sig)</span>
          </a>
        </div>
      
        <div class="method-description">
        </div>
      </div>

      <div id="method-M000528" class="method-detail">
        <a name="M000528"></a>

        <div class="method-heading">
          <a href="Connection.src/M000528.html" target="Code" class="method-signature"
            onclick="popupCode('Connection.src/M000528.html');return false;">
          <span class="method-name">close_connection</span><span class="method-args">(after_writing = false)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
<a
href="Connection.html#M000528">EventMachine::Connection#close_connection</a>
is called only by user code, and never by the event loop. You may call this
method against a connection object in any callback handler, whether or not
the callback was made against the connection you want to close. <a
href="Connection.html#M000528">close_connection</a> <em>schedules</em> the
connection to be closed at the next available opportunity within the event
loop. You may not assume that the connection is closed when <a
href="Connection.html#M000528">close_connection</a> returns. In particular,
the framework will callback the <a
href="Connection.html#M000527">unbind</a> method for the particular
connection at a point shortly after you call <a
href="Connection.html#M000528">close_connection</a>. You may assume that
the <a href="Connection.html#M000527">unbind</a> callback will take place
sometime after your call to <a
href="Connection.html#M000528">close_connection</a> completes. In other
words, the <a href="Connection.html#M000527">unbind</a> callback will not
re-enter your code &quot;inside&quot; of your call to <a
href="Connection.html#M000528">close_connection</a>. However, it&#8216;s
not guaranteed that a future version of <a
href="../EventMachine.html">EventMachine</a> will not change this behavior.
</p>
<p>
<a href="Connection.html#M000528">close_connection</a> will <em>silently
discard</em> any outbound data which you have sent to the connection using
<a href="Connection.html#M000531">EventMachine::Connection#send_data</a>
but which has not yet been sent across the network. If you want to avoid
this behavior, use <a
href="Connection.html#M000530">EventMachine::Connection#close_connection_after_writing</a>.
</p>
        </div>
      </div>

      <div id="method-M000530" class="method-detail">
        <a name="M000530"></a>

        <div class="method-heading">
          <a href="Connection.src/M000530.html" target="Code" class="method-signature"
            onclick="popupCode('Connection.src/M000530.html');return false;">
          <span class="method-name">close_connection_after_writing</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
<a
href="Connection.html#M000530">EventMachine::Connection#close_connection_after_writing</a>
is a variant of <a href="Connection.html#M000528">close_connection</a>. All
of the descriptive comments given for <a
href="Connection.html#M000528">close_connection</a> also apply to <a
href="Connection.html#M000530">close_connection_after_writing</a>, <em>with
one exception:</em> If the connection has outbound data sent using send_dat
but which has not yet been sent across the network, <a
href="Connection.html#M000530">close_connection_after_writing</a> will
schedule the connection to be closed <em>after</em> all of the outbound
data has been safely written to the remote peer.
</p>
<p>
Depending on the amount of outgoing data and the speed of the network,
considerable time may elapse between your call to <a
href="Connection.html#M000530">close_connection_after_writing</a> and the
actual closing of the socket (at which time the <a
href="Connection.html#M000527">unbind</a> callback will be called by the
event loop). During this time, you <em>may not</em> call <a
href="Connection.html#M000531">send_data</a> to transmit additional data
(that is, the connection is closed for further writes). In very rare cases,
you may experience a <a href="Connection.html#M000526">receive_data</a>
callback after your call to <a
href="Connection.html#M000530">close_connection_after_writing</a>,
depending on whether incoming data was in the process of being received on
the connection at the moment when you called <a
href="Connection.html#M000530">close_connection_after_writing</a>. Your
protocol handler must be prepared to properly deal with such data (probably
by ignoring it).
</p>
        </div>
      </div>

      <div id="method-M000540" class="method-detail">
        <a name="M000540"></a>

        <div class="method-heading">
          <a href="Connection.src/M000540.html" target="Code" class="method-signature"
            onclick="popupCode('Connection.src/M000540.html');return false;">
          <span class="method-name">comm_inactivity_timeout</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
<a href="Connection.html#M000540">comm_inactivity_timeout</a> returns the
current value (in seconds) of the inactivity-timeout property of
network-connection and datagram-socket objects. A nonzero value indicates
that the connection or socket will automatically be closed if no read or
write activity takes place for at least that number of seconds. A zero
value (the default) specifies that no automatic timeout will take place.
</p>
        </div>
      </div>

      <div id="method-M000541" class="method-detail">
        <a name="M000541"></a>

        <div class="method-heading">
          <a href="Connection.src/M000541.html" target="Code" class="method-signature"
            onclick="popupCode('Connection.src/M000541.html');return false;">
          <span class="method-name">comm_inactivity_timeout=</span><span class="method-args">(value)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Alias for <a
href="Connection.html#M000542">set_comm_inactivity_timeout</a>.
</p>
        </div>
      </div>

      <div id="method-M000533" class="method-detail">
        <a name="M000533"></a>

        <div class="method-heading">
          <a href="Connection.src/M000533.html" target="Code" class="method-signature"
            onclick="popupCode('Connection.src/M000533.html');return false;">
          <span class="method-name">connection_completed</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
<a href="Connection.html#M000533">connection_completed</a> is called by the
event loop when a remote TCP connection attempt completes successfully. You
can expect to get this notification after calls to <a
href="../EventMachine.html#M000259">EventMachine#connect</a>. Remember that
<a href="../EventMachine.html">EventMachine</a> makes remote connections
asynchronously, just as with any other kind of network event. <a
href="Connection.html#M000533">connection_completed</a> is intended
primarily to assist with network diagnostics. For normal protocol handling,
use <a href="Connection.html#M000525">post_init</a> to perform initial work
on a new connection (such as send an initial set of data). <a
href="Connection.html#M000525">post_init</a> will always be called. <a
href="Connection.html#M000533">connection_completed</a> will only be called
in case of a successful completion. A connection-attempt which fails will
receive a call to <a href="Connection.html#M000527">unbind</a> after the
failure.
</p>
        </div>
      </div>

      <div id="method-M000529" class="method-detail">
        <a name="M000529"></a>

        <div class="method-heading">
          <a href="Connection.src/M000529.html" target="Code" class="method-signature"
            onclick="popupCode('Connection.src/M000529.html');return false;">
          <span class="method-name">detach</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
<a href="Connection.html#M000529">EventMachine::Connection#detach</a> will
remove the given connection from the event loop. The connection&#8216;s
socket remains open and its file descriptor number is returned
</p>
        </div>
      </div>

      <div id="method-M000532" class="method-detail">
        <a name="M000532"></a>

        <div class="method-heading">
          <a href="Connection.src/M000532.html" target="Code" class="method-signature"
            onclick="popupCode('Connection.src/M000532.html');return false;">
          <span class="method-name">error?</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns true if the connection is in an error state, false otherwise. In
general, you can detect the occurrence of communication errors or
unexpected disconnection by the remote peer by handing the <a
href="Connection.html#M000527">unbind</a> method. In some cases, however,
it&#8216;s useful to check the status of the connection using error? before
attempting to send data. This function is synchronous: it will return
immediately without blocking.
</p>
        </div>
      </div>

      <div id="method-M000547" class="method-detail">
        <a name="M000547"></a>

        <div class="method-heading">
          <a href="Connection.src/M000547.html" target="Code" class="method-signature"
            onclick="popupCode('Connection.src/M000547.html');return false;">
          <span class="method-name">get_outbound_data_size</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
        </div>
      </div>

      <div id="method-M000536" class="method-detail">
        <a name="M000536"></a>

        <div class="method-heading">
          <a href="Connection.src/M000536.html" target="Code" class="method-signature"
            onclick="popupCode('Connection.src/M000536.html');return false;">
          <span class="method-name">get_peername</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
<a href="Connection.html#M000536">get_peername</a> is used with
stream-connections to obtain the identity of the remotely-connected peer.
If a peername is available, this method returns a sockaddr structure. The
method returns nil if no peername is available. You can use
Socket#unpack_sockaddr_in and its variants to obtain the values contained
in the peername structure returned from <a
href="Connection.html#M000536">get_peername</a>.
</p>
        </div>
      </div>

      <div id="method-M000538" class="method-detail">
        <a name="M000538"></a>

        <div class="method-heading">
          <a href="Connection.src/M000538.html" target="Code" class="method-signature"
            onclick="popupCode('Connection.src/M000538.html');return false;">
          <span class="method-name">get_pid</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns the PID (kernel process identifier) of a subprocess associated with
this <a href="Connection.html">Connection</a> object. For use with <a
href="../EventMachine.html#M000270">EventMachine#popen</a> and similar
methods. Returns nil when there is no meaningful subprocess.
</p>
        </div>
      </div>

      <div id="method-M000537" class="method-detail">
        <a name="M000537"></a>

        <div class="method-heading">
          <a href="Connection.src/M000537.html" target="Code" class="method-signature"
            onclick="popupCode('Connection.src/M000537.html');return false;">
          <span class="method-name">get_sockname</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
<a href="Connection.html#M000537">get_sockname</a> is used with
stream-connections to obtain the identity of the local side of the
connection. If a local name is available, this method returns a sockaddr
structure. The method returns nil if no local name is available. You can
use Socket#unpack_sockaddr_in and its variants to obtain the values
contained in the local-name structure returned from <a
href="Connection.html#M000537">get_sockname</a>.
</p>
        </div>
      </div>

      <div id="method-M000539" class="method-detail">
        <a name="M000539"></a>

        <div class="method-heading">
          <a href="Connection.src/M000539.html" target="Code" class="method-signature"
            onclick="popupCode('Connection.src/M000539.html');return false;">
          <span class="method-name">get_status</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns a subprocess exit status. Only useful for popen. Call it in your <a
href="Connection.html#M000527">unbind</a> handler.
</p>
        </div>
      </div>

      <div id="method-M000525" class="method-detail">
        <a name="M000525"></a>

        <div class="method-heading">
          <a href="Connection.src/M000525.html" target="Code" class="method-signature"
            onclick="popupCode('Connection.src/M000525.html');return false;">
          <span class="method-name">post_init</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
<a href="Connection.html#M000525">EventMachine::Connection#post_init</a> is
called by the event loop immediately after the network connection has been
established, and before resumption of the network loop. This method is
generally not called by user code, but is called automatically by the event
loop. The base-class implementation is a no-op. This is a very good place
to initialize instance variables that will be used throughout the lifetime
of the network connection.
</p>
        </div>
      </div>

      <div id="method-M000526" class="method-detail">
        <a name="M000526"></a>

        <div class="method-heading">
          <a href="Connection.src/M000526.html" target="Code" class="method-signature"
            onclick="popupCode('Connection.src/M000526.html');return false;">
          <span class="method-name">receive_data</span><span class="method-args">(data)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
<a href="Connection.html#M000526">EventMachine::Connection#receive_data</a>
is called by the event loop whenever data has been received by the network
connection. It is never called by user code. <a
href="Connection.html#M000526">receive_data</a> is called with a single
parameter, a String containing the network protocol data, which may of
course be binary. You will generally redefine this method to perform your
own processing of the incoming data.
</p>
<p>
Here&#8216;s a key point which is essential to understanding the
event-driven programming model: <em><a
href="../EventMachine.html">EventMachine</a> knows absolutely nothing about
the protocol which your code implements.</em> You must not make any
assumptions about the size of the incoming data packets, or about their
alignment on any particular intra-message or PDU boundaries (such as line
breaks). <a href="Connection.html#M000526">receive_data</a> can and will
send you arbitrary chunks of data, with the only guarantee being that the
data is presented to your code in the order it was collected from the
network. Don&#8216;t even assume that the chunks of data will correspond to
network packets, as <a href="../EventMachine.html">EventMachine</a> can and
will coalesce several incoming packets into one, to improve performance.
The implication for your code is that you generally will need to implement
some kind of a state machine in your redefined implementation of <a
href="Connection.html#M000526">receive_data</a>. For a better understanding
of this, read through the examples of specific protocol handlers given
elsewhere in this package. (STUB, WE MUST ADD THESE!)
</p>
<p>
The base-class implementation of <a
href="Connection.html#M000526">receive_data</a> (which will be invoked if
you don&#8216;t redefine it) simply prints the size of each incoming data
packet to stdout.
</p>
        </div>
      </div>

      <div id="method-M000543" class="method-detail">
        <a name="M000543"></a>

        <div class="method-heading">
          <a href="Connection.src/M000543.html" target="Code" class="method-signature"
            onclick="popupCode('Connection.src/M000543.html');return false;">
          <span class="method-name">reconnect</span><span class="method-args">(server, port)</span>
          </a>
        </div>
      
        <div class="method-description">
        </div>
      </div>

      <div id="method-M000531" class="method-detail">
        <a name="M000531"></a>

        <div class="method-heading">
          <a href="Connection.src/M000531.html" target="Code" class="method-signature"
            onclick="popupCode('Connection.src/M000531.html');return false;">
          <span class="method-name">send_data</span><span class="method-args">(data)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
<a href="Connection.html#M000531">EventMachine::Connection#send_data</a> is
only called by user code, never by the event loop. You call this method to
send data to the remote end of the network connection. <a
href="Connection.html#M000531">send_data</a> is called with a single String
argument, which may of course contain binary data. You can call <a
href="Connection.html#M000531">send_data</a> any number of times. <a
href="Connection.html#M000531">send_data</a> is an instance method of an
object derived from <a href="Connection.html">EventMachine::Connection</a>
and containing your mixed-in handler code), so if you call it without
qualification within a callback function, the data will be sent to the same
network connection that generated the callback. Calling self.send_data is
exactly equivalent.
</p>
<p>
You can also call <a href="Connection.html#M000531">send_data</a> to write
to a connection <em>other than the one whose callback you are calling <a
href="Connection.html#M000531">send_data</a> from.</em> This is done by
recording the value of the connection in any callback function (the value
self), in any variable visible to other callback invocations on the same or
different connection objects. (Need an example to make that clear.)
</p>
        </div>
      </div>

      <div id="method-M000535" class="method-detail">
        <a name="M000535"></a>

        <div class="method-heading">
          <a href="Connection.src/M000535.html" target="Code" class="method-signature"
            onclick="popupCode('Connection.src/M000535.html');return false;">
          <span class="method-name">send_datagram</span><span class="method-args">(data, recipient_address, recipient_port)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
<a href="Connection.html#M000535">send_datagram</a> is for sending UDP
messages. This method may be called from any <a
href="Connection.html">Connection</a> object that refers to an open
datagram socket (see <a
href="../EventMachine.html#M000263">EventMachine#open_datagram_socket</a>).
The method sends a UDP (datagram) packet containing the data you specify,
to a remote peer specified by the IP address and port that you give as
parameters to the method. Observe that you may send a zero-length packet
(empty string). However, you may not send an arbitrarily-large data packet
because your operating system will enforce a platform-specific limit on the
size of the outbound packet. (Your kernel will respond in a
platform-specific way if you send an overlarge packet: some will send a
truncated packet, some will complain, and some will silently drop your
request). On LANs, it&#8216;s usually OK to send datagrams up to about 4000
bytes in length, but to be really safe, send messages smaller than the
Ethernet-packet size (typically about 1400 bytes). Some very restrictive
WANs will either drop or truncate packets larger than about 500 bytes.
</p>
        </div>
      </div>

      <div id="method-M000544" class="method-detail">
        <a name="M000544"></a>

        <div class="method-heading">
          <a href="Connection.src/M000544.html" target="Code" class="method-signature"
            onclick="popupCode('Connection.src/M000544.html');return false;">
          <span class="method-name">send_file_data</span><span class="method-args">(filename)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Like <a
href="Connection.html#M000531">EventMachine::Connection#send_data</a>, this
sends data to the remote end of the network connection. <a
href="Connection.html">EventMachine::Connection</a>@<a
href="Connection.html#M000544">send_file_data</a> takes a filename as an
argument, though, and sends the contents of the file, in one chunk.
Contributed by Kirk Haines.
</p>
        </div>
      </div>

      <div id="method-M000542" class="method-detail">
        <a name="M000542"></a>

        <div class="method-heading">
          <a href="Connection.src/M000542.html" target="Code" class="method-signature"
            onclick="popupCode('Connection.src/M000542.html');return false;">
          <span class="method-name">set_comm_inactivity_timeout</span><span class="method-args">(value)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
<a href="Connection.html#M000541">comm_inactivity_timeout=</a> allows you
to set the inactivity-timeout property for a network connection or datagram
socket. Specify a non-negative numeric value in seconds. If the value is
greater than zero, the connection or socket will automatically be closed if
no read or write activity takes place for at least that number of seconds.
Specify a value of zero to indicate that no automatic timeout should take
place. Zero is the default value.
</p>
        </div>
      </div>

      <div id="method-M000534" class="method-detail">
        <a name="M000534"></a>

        <div class="method-heading">
          <a href="Connection.src/M000534.html" target="Code" class="method-signature"
            onclick="popupCode('Connection.src/M000534.html');return false;">
          <span class="method-name">start_tls</span><span class="method-args">(args={})</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Call <a href="Connection.html#M000534">start_tls</a> at any point to
initiate TLS encryption on connected streams. The method is smart enough to
know whether it should perform a server-side or a client-side handshake. An
appropriate place to call <a href="Connection.html#M000534">start_tls</a>
is in your redefined <a href="Connection.html#M000525">post_init</a>
method, or in the <a
href="Connection.html#M000533">connection_completed</a> handler for an
outbound connection.
</p>
<p>
<a href="Connection.html#M000534">start_tls</a> takes an optional parameter
hash that allows you to specify certificate and other options to be used
with this <a href="Connection.html">Connection</a> object. Here are the
currently-supported options: :cert_chain_file : takes a String, which is
interpreted as the name of a readable file in the
</p>
<pre>
  local filesystem. The file is expected to contain a chain of X509 certificates in
  PEM format, with the most-resolved certificate at the top of the file, successive
  intermediate certs in the middle, and the root (or CA) cert at the bottom.
</pre>
<p>
:private_key_file : tales a String, which is interpreted as the name of a
readable file in the
</p>
<pre>
  local filesystem. The file must contain a private key in PEM format.
</pre>
        </div>
      </div>

      <div id="method-M000545" class="method-detail">
        <a name="M000545"></a>

        <div class="method-heading">
          <a href="Connection.src/M000545.html" target="Code" class="method-signature"
            onclick="popupCode('Connection.src/M000545.html');return false;">
          <span class="method-name">stream_file_data</span><span class="method-args">(filename, args={})</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Open a file on the filesystem and send it to the remote peer. This returns
an object of type <a href="Deferrable.html">EventMachine::Deferrable</a>.
The object&#8216;s callbacks will be executed on the reactor main thread
when the file has been completely scheduled for transmission to the remote
peer. Its errbacks will be called in case of an error (such as
file-not-found). <a href="Connection.html#M000545">stream_file_data</a>
employs various strategems to achieve the fastest possible performance,
balanced against minimum consumption of memory.
</p>
<p>
You can control the behavior of <a
href="Connection.html#M000545">stream_file_data</a> with the optional
arguments parameter. Currently-supported arguments are: :http_chunks, a
boolean flag which defaults false. If true, this flag streams the file data
in a format compatible with the HTTP chunked-transfer encoding.
</p>
<p>
Warning: this feature has an implicit dependency on an outboard extension,
evma_fastfilereader. You must install this extension in order to use <a
href="Connection.html#M000545">stream_file_data</a> with files larger than
a certain size (currently 8192 bytes).
</p>
        </div>
      </div>

      <div id="method-M000527" class="method-detail">
        <a name="M000527"></a>

        <div class="method-heading">
          <a href="Connection.src/M000527.html" target="Code" class="method-signature"
            onclick="popupCode('Connection.src/M000527.html');return false;">
          <span class="method-name">unbind</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
<a href="Connection.html#M000527">EventMachine::Connection#unbind</a> is
called by the framework whenever a connection (either a server or client
connection) is closed. The close can occur because your code intentionally
closes it (see <a href="Connection.html#M000528">close_connection</a> and
<a href="Connection.html#M000530">close_connection_after_writing</a>),
because the remote peer closed the connection, or because of a network
error. You may not assume that the network connection is still open and
able to send or receive data when the callback to <a
href="Connection.html#M000527">unbind</a> is made. This is intended only to
give you a chance to clean up associations your code may have made to the
connection object while it was open.
</p>
        </div>
      </div>


    </div>


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>