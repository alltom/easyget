--- !ruby/object:RI::MethodDescription 
aliases: []

block_params: c
comment: 
- !ruby/struct:SM::Flow::P 
  body: EventMachine#connect initiates a TCP connection to a remote server and sets up event-handling for the connection. You can call EventMachine#connect in the block supplied to EventMachine#run or in any callback method.
- !ruby/struct:SM::Flow::P 
  body: EventMachine#connect takes the IP address (or hostname) and port of the remote server you want to connect to. It also takes an optional handler Module which you must define, that contains the callbacks that will be invoked by the event loop on behalf of the connection.
- !ruby/struct:SM::Flow::P 
  body: See the description of EventMachine#start_server for a discussion of the handler Module. All of the details given in that description apply for connections created with EventMachine#connect.
- !ruby/struct:SM::Flow::H 
  level: 3
  text: Usage Example
- !ruby/struct:SM::Flow::P 
  body: Here's a program which connects to a web server, sends a naive request, parses the HTTP header of the response, and then (antisocially) ends the event loop, which automatically drops the connection (and incidentally calls the connection's unbind method).
- !ruby/struct:SM::Flow::VERB 
  body: " require 'rubygems'\n require 'eventmachine'\n\n module DumbHttpClient\n\n   def post_init\n     send_data &quot;GET / HTTP/1.1\\r\\nHost: _\\r\\n\\r\\n&quot;\n     @data = &quot;&quot;\n   end\n\n   def receive_data data\n     @data &lt;&lt; data\n     if  @data =~ /[\\n][\\r]*[\\n]/m\n       puts &quot;RECEIVED HTTP HEADER:&quot;\n       $`.each {|line| puts &quot;&gt;&gt;&gt; #{line}&quot; }\n\n       puts &quot;Now we'll terminate the loop, which will also close the connection&quot;\n       EventMachine::stop_event_loop\n     end\n   end\n\n   def unbind\n     puts &quot;A connection has terminated&quot;\n   end\n\n end # DumbHttpClient\n\n EventMachine::run {\n   EventMachine::connect &quot;www.bayshorenetworks.com&quot;, 80, DumbHttpClient\n }\n puts &quot;The event loop has ended&quot;\n"
- !ruby/struct:SM::Flow::P 
  body: "There are times when it's more convenient to define a protocol handler as a Class rather than a Module. Here's how to do this:"
- !ruby/struct:SM::Flow::VERB 
  body: " class MyProtocolHandler &lt; EventMachine::Connection\n   def initialize *args\n     super\n     # whatever else you want to do here\n   end\n\n   #.......your other class code\n end # class MyProtocolHandler\n"
- !ruby/struct:SM::Flow::P 
  body: "If you do this, then an instance of your class will be instantiated to handle every network connection created by your code or accepted by servers that you create. If you redefine #post_init in your protocol-handler class, your #post_init method will be called <em>inside</em> the call to #super that you will make in your #initialize method (if you provide one)."
full_name: EventMachine::connect
is_singleton: true
name: connect
params: (server, port, handler=nil, *args) {|c| ...}
visibility: public
